import * as codec from '@ipld/dag-json';
import { sha256 } from 'multiformats/hashes/sha2';
import { CID } from 'multiformats/cid';

import { BlockProgressInterface } from '@vulcanize/util';

import { Indexer } from './indexer';
import { IPLDBlock } from './entity/IPLDBlock';

export async function blockProcessingCompleteHandler (indexer: Indexer, jobData: any): Promise<void> {
  // Get events for current block and make an entry of updated values in IPLDBlock.

  const { blockHash } = jobData;
  const events = await indexer.getBlockEvents(blockHash);

  if (!events) return;

  const ipldUpdates = events.map(async (event): Promise<void> => {
    const block = event.block;
    const contractAddress = event.contract;

    const oldIpldBlock = await indexer.getIPLDBlock(block, contractAddress);

    const ipldBlockData: any = {};
    const eventData = indexer.getResultEvent(event);

    switch (event.eventName) {
      case 'Transfer': {
        const { from, to } = eventData.event;

        const fromBalance = await indexer.balanceOf(blockHash, contractAddress, from);
        const toBalance = await indexer.balanceOf(blockHash, contractAddress, to);

        // {
        //   "_balances": {
        //      "0xCA6D29232D1435D8198E3E5302495417dD073d61": {
        //         "value": 100
        //      },
        //      "0xDC7d7A8920C8Eecc098da5B7522a5F31509b5Bfc": {
        //         "value": 999999999999999999900
        //      }
        //   }
        // }
        ipldBlockData._balances = {};
        ipldBlockData._balances[from] = fromBalance;
        ipldBlockData._balances[to] = toBalance;

        break;
      }

      case 'Approval': {
        const { owner, spender } = eventData.event;
        const allowance = await indexer.allowance(blockHash, contractAddress, owner, spender);

        // {
        //   "_allowances": {
        //      "0xDC7d7A8920C8Eecc098da5B7522a5F31509b5Bfc": {
        //         "0xCA6D29232D1435D8198E3E5302495417dD073d61": {
        //            "value": 10
        //         }
        //      }
        //   }
        // }
        ipldBlockData._allowances = {};
        ipldBlockData._allowances[owner] = {};
        ipldBlockData._allowances[owner][spender] = allowance;

        break;
      }
    }

    if (block) {
      const ipldBlock = await prepareIPLDBlock(block, contractAddress, ipldBlockData, oldIpldBlock);
      await indexer.saveOrUpdateIPLDBlock(ipldBlock);
    }
  });

  await Promise.all(ipldUpdates);
}

async function prepareIPLDBlock (block: BlockProgressInterface, contractAddress: string, data: any, oldIpldBlock?: IPLDBlock):Promise<any> {
  // If an IPLDBlock for { block, contractAddress } already exists, update the data field.
  if (oldIpldBlock) {
    const oldData = codec.decode(Buffer.from(oldIpldBlock.data));
    data = Object.assign(oldData, data);
  }

  // Encoding the data using dag-json codec.
  const bytes = codec.encode(data);

  // Calculating sha256 (multi)hash of the encoded data.
  const hash = await sha256.digest(bytes);

  // Calculating the CID: v1, code: dag-json, hash.
  const cid = CID.create(1, codec.code, hash);

  return {
    block,
    contractAddress,
    cid: cid.toString(),
    data: bytes
  };
}
